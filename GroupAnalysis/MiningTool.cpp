#include "MiningTool.h"
#include <math.h>
#include <algorithm> 

MiningTool::MiningTool()
{
}


MiningTool::~MiningTool()
{
}

double MiningTool::miningDistance(OriginPoint a, OriginPoint b) {

	double tDiff = abs(a.getPosixtime() - b.getPosixtime())/60;	//以分钟为单位，暂定理想编群tDiff应在20以内
	if (tDiff == 0)
		tDiff = 1;
	double distance = distanceBetweenPoints(a.getLongitude(), a.getLatitude(), b.getLongitude(), b.getLatitude())*1000;//以M为单位计算,暂定理想dis为1000级，log后为10级
	if (distance == 0)
		distance = 2;
	double angleDiff = fabs(a.getAngle() - b.getAngle());
	double speedDiff = fabs(a.getSpeed() - b.getSpeed());
	double res = (0.6*log(distance) + 0.2*(angleDiff + speedDiff)) * tDiff;
	printf("%10lg\t", res);
	return res;
}


double MiningTool::distanceBetweenPoints(double lastLongitude, double lastLatitude, double longitude, double latitude) {
	double res = 0;
	if (lastLatitude <= 90 && lastLongitude <= 180) {	
		double p = 0.017453292519943295;    // Math.PI / 180
		double a = 0.5 - cos((latitude - lastLatitude) * p) / 2 + cos(latitude * p) * cos(lastLatitude * p) *(0.5 - cos((longitude - lastLongitude) * p) / 2);

		res = 6371.393 * asin(sqrt(a)); // 2 * R; R = 6371 km
	}
	return res;
}   

bool posixSort(OriginPoint a, OriginPoint b) {
	return a.getPosixtime() < b.getPosixtime();
}

bool samePoint(OriginPoint a, OriginPoint b) {
	if (a.getTargetID()!=b.getTargetID())
		return false;
	return a.getLongitude() == b.getLongitude() && a.getPosixtime() == b.getPosixtime() && a.getLatitude() == b.getLatitude();
}

void MiningTool::analyzeBySnapshot(vector<OriginPoint> &Points, int trackNum, int startTime, int endTime, int timeInterval) {
	
	std::sort(Points.begin(), Points.end(), posixSort);//按时间排序

	Points.erase(std::unique(Points.begin(), Points.end(),samePoint), Points.end());//去重

	int tmpStartTime = startTime, tmpEndTime = startTime + timeInterval;
	int pCounter = 0, pNum = Points.size();
	while (tmpStartTime <= endTime) {		//每个时间切片轮询
		vector<int> candidateIdx;
		bool multiTarget = false;
		do{
			if (Points[pCounter].insideSnapshot(tmpStartTime, tmpEndTime)) {	//该点迹落于时间片内:1.判断是否为新目标 2.push入候选集
				if (!multiTarget && !candidateIdx.empty() && !OriginPoint::sameTarget(Points[pCounter], Points[candidateIdx.back()]))//先与candidate最新元素比对
					multiTarget = true;//将multiTarget加入条件，减少后续判断

				candidateIdx.push_back(pCounter);
			}else	//不在时间片内，则跳出，进入下一时间片
				break;			
		} while (++pCounter < pNum);
		
		if(multiTarget)//多目标情况下再进行聚类
			snapshotAnalyze(Points,candidateIdx);

		tmpStartTime = tmpEndTime;//更新时间切片
		tmpEndTime += timeInterval;
	}
}

void MiningTool::snapshotAnalyze(vector<OriginPoint> Point,vector<int>candidateIdx)
{
	vector<set<string> > groups;
	//TODO  优化，算出不同目标之间最近点距离进行判断是否要聚类
	int PointNum = (int)candidateIdx.size();
	//int** disMat = new int*[PointNum];
	//for (int counter = 0; counter < PointNum; ++counter) 
	//	disMat[counter] = new int[PointNum];

	Chameleon chameleon(Point, candidateIdx,4);
	//knn连接图生成
	chameleon.chameleonCluster();
	//生成簇进行目标分析，单目标簇删去，多目标簇进行簇内去重
	for (Cluster c : chameleon.getClusters()) {
		set<string> tmp= Chameleon::clusterAnalyse(c);
		if (tmp.size() > 1)
			groups.push_back(tmp);
	}	
	//大簇拆分(因为此时的knn为仅考虑邻接权重的结果，后续度量回加入EC，SEC)
	//层次聚类	
}
